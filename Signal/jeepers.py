# This file is part of ZNC-Signal <https://github.com/poppyschmo/znc-signal>,
# licensed under Apache 2.0 <http://www.apache.org/licenses/LICENSE-2.0>.

"""
Miscellaneous objects for the DBus connection
"""

from asyncio.events import AbstractEventLoop
from asyncio.futures import Future as AsyncFuture
from jeepney.wrappers import MessageGenerator, new_method_call  # noqa E402
from typing import List, TypeVar
from collections import namedtuple


R = TypeVar("R", str, List[str])

incoming_NT = namedtuple("Incoming",
                         "timestamp source groupID message attachments")


class SignalMG(MessageGenerator):
    """Modified auto-generated DBus bindings
    Generated by jeepney version 0.3.1
    Object path: /org/asamk/Signal
    Bus name   : org.asamk.Signal
    """
    interface = 'org.asamk.Signal'

    def __init__(self, object_path='/org/asamk/Signal',
                 bus_name='org.asamk.Signal'):
        super().__init__(object_path=object_path, bus_name=bus_name)

    def updateGroup(self, groupId: List[bytes], name: str, members: List[str],
                    avatar: str):
        return new_method_call(self, 'updateGroup', 'aysass',
                               (groupId, name, members, avatar))

    def sendEndSessionMessage(self, recipients: List[str]):
        return new_method_call(self, 'sendEndSessionMessage', 'as',
                               (recipients,))

    def sendGroupMessage(self, message: str, attachments: List[str],
                         groupId: List[bytes]):
        return new_method_call(self, 'sendGroupMessage', 'sasay',
                               (message, attachments, groupId))

    # Overloaded
    def sendMessage(self, message: str, attachments: List[str], recip: R):
        signature = "sass" if isinstance(recip, str) else "sasas"
        return new_method_call(self, 'sendMessage',
                               signature, (message, attachments, recip))

    def getContactName(self, number: str):
        return new_method_call(self, 'getContactName', 's', (number,))

    def setContactName(self, number: str, name: str):
        return new_method_call(self, 'setContactName', 'ss', (number, name))

    def getGroupName(self, groupId: List[bytes]):
        return new_method_call(self, 'getGroupName', 'ay', (groupId,))

    def getGroupMembers(self, groupId: List[bytes]):
        return new_method_call(self, 'getGroupMembers', 'ay', (groupId,))


class FakeLoop(AbstractEventLoop):
    """Kludge for DBusConnection's incoming data dispatcher (router)

    Obviously, this is pure mockery and not a real shim.

    Notes
    ~~~~~
    CCron.StartMaxCycles is overloaded. The form called by CTimer takes
    a double, dTimeSequence, which CCron massages into a timeval struct,
    m_tTimeSequence. ZNC passes in an unsigned int, however, so the
    microsecs portion (tv_usec) is narrowed away on arrival.
    """
    def __init__(self, module):
        self.module = module

    def call_later(self, delay, callback, *args):
        """Enable ``FakeFuture._schedule_callbacks``

        This is just a formality and could just as well fire the
        callback directly (straight away).
        """

        def RunJob(_self):
            callback(*args)
            _self.Stop()

        from . import znc
        FakeTimer = type(callback.__name__, (znc.Timer,), dict(RunJob=RunJob))
        self.module.CreateTimer(FakeTimer, interval=int(delay), cycles=1,
                                label=callback.__name__,
                                description=repr(callback))

    def get_debug(self):
        return False


class FakeFuture(AsyncFuture):
    fake_loop = None

    def __init__(self):
        super().__init__(loop=self.fake_loop)
